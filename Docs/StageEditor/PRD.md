# “关卡编辑器”系统需求说明书 (PRD)

---

### **“关卡编辑器”系统需求说明书 (PRD)**

**文档版本:** **2.1**

**产品名称:** 动态舞台系统 (Dynamic Stage System)

**目标读者:** 项目制作人、全体开发团队成员 (策划、程序、美术、QA)

---

### **1. 项目背景与问题陈述**

随着我们游戏世界的规模和互动复杂性的不断提升，现有的关卡构建工作流已成为制约我们创作效率和游戏品质的主要瓶颈。团队目前面临三大核心痛点：

- **1.1 状态管理混乱:** 关卡需要表现出丰富的动态变化（如一个村庄在和平、被攻击、被摧毁后的不同样貌）。当前通过复杂的蓝图分支和手动调整Actor属性的方式来实现，不仅效率低下，而且极易出错，导致关卡状态难以维护和迭代。
- **1.2 团队协作冲突:** 多个设计师在同一个大地图区域并行工作时，对共享关卡文件（`.umap`）的修改频繁引发版本控制系统的冲突。解决这些冲突耗费了大量宝贵的开发时间，并时常因合并失误导致工作成果丢失。
- **1.3 性能与加载不可控:** 关卡资源的加载策略较为粗放，常常导致非必要资源（如未激活任务的NPC和道具）常驻内存，不仅造成了不必要的性能开销，也限制了场景内容的丰富度。

---

### **2. 产品愿景与目标**

本系统旨在提供一套全新的、以“区域化”和“数据驱动”为核心的动态世界构建方案，彻底解决上述问题。

- **核心愿景:** 我们致力于将关卡的构建与编排体验，打造成像**执导一出戏剧**一样富有创造力且易于管理。整个游戏世界被视为由无数个独立的**舞台 (Stages)** 组成，每个舞台都能根据剧情需要，上演不同的**幕 (Acts)**，而舞台上的一切，无论是角色还是布景，都是可被导演精确控制的**道具 (Props)**。
- **核心目标:**
    - **提升效率:** 将创建和配置一个全新区域状态所需的时间，从数小时缩短至分钟级别。
    - **促进协作:** 彻底消除因共享关卡文件导致的绝大部分版本冲突，支持团队在同一区域内高效并行工作。
    - **优化性能:** 实现真正的“按需加载”，确保只有当前逻辑上必需的资源才会被加载至内存。

---

### **3. 核心概念与词汇表**

为了统一团队沟通语言，我们定义以下核心术语：

- **舞台 (Stage):** 一个放置在关卡中的`AStage` Actor。它在世界中划定了一块区域，扮演**“区域场景导演”**的角色。它负责管理其管辖范围内的所有`Prop`，并根据游戏逻辑决定当前应该上演哪一“幕”(`Act`)。
- **幕 (Act):** 一个在`Stage`中定义的纯数据结构 (`FAct`)。它如同戏剧中的一幕，是一个**“场景状态的蓝图”**。每一个`Act`都定义了一组`Prop`应该呈现的状态，并强力绑定了一组需要被加载/卸载的资源（通过一个Data Layer）。
- **道具 (Prop):** 一个继承自我们定制的基类 **`AProp`** 的Actor。它是舞台上所有**受控单元**的基石。无论是NPC、触发器，还是墙壁、灯光，只要导演（`Stage`）需要控制其状态，它就**必须**是一个`AProp`的子类。每个`Prop`都拥有一个在该`Stage`内唯一的ID。
- **道具状态 (Prop State):** 在`AProp`基类中定义的一个**`int32`（整数）类型的核心变量**，命名为`PropState`。这个变量是`Stage`与`Prop`之间沟通的**唯一桥梁**。`Act`中记录的就是一个`Prop`的目标`PropState`值。

---

### **4. 功能需求 (V1.0 - MVP)**

**作为一名关卡策划（导演），我希望能够：**

- **4.1 布置舞台 (Stage Setup)**
    - 我可以在世界地图上放置一个`AStage` Actor来定义一个独立的表演区域。
    - 我可以将任何继承自`AProp`基类的Actor注册到`AStage`中，使其成为一个可被控制的`Prop`。
- **4.2 编写剧本 (Act Definition)**
    - 我可以为我的`AStage`创建多个`Act`（幕），例如，“Act_Peaceful”、“Act_UnderAttack”、“Act_Ruined”。
    - 每一个`Act`都必须能关联一个指定的Data Layer，用于管理该`Act`专属的资源加载。
    - 对于每一个`Act`，我可以为任意一个`Prop`**手动指定一个整数值**，作为其在该`Act`下的目标`PropState`。
        - **示例:** 在`Act_UnderAttack`中，我可以找到名为“Village_Gate”的`Prop`，并为它的`PropState`输入框填上整数`2`。
- **4.3 导演道具行为 (Prop Logic Implementation)**
    - 我可以在`AProp`的子类蓝图中，**响应`PropState`变量的变化**。
    - 我可以基于`PropState`的整数值，使用`Switch on Int`节点来编写自定义逻辑，以驱动`Prop`的具体行为表现。
        - **示例:** 在`BP_Village_Gate`的蓝图中，我可以添加逻辑：“当`PropState`变量变为`2`时，在门前生成障碍物特效并关闭交互；当变为`3`时，切换到破损的模型。”
- **4.4 编排演出 (Act Orchestration)**
    - 我可以在`AStage`的蓝图中，编写逻辑来控制在游戏运行时激活哪些`Act`。
    - `AStage`必须支持**同时激活多个`Act**`。当多个`Act`试图设置同一个`Prop`的`PropState`时，需要有一个**优先级**机制来解决冲突，以优先级最高的`Act`为准。
    - 当一个`Act`被激活时，`AStage`会自动找到该`Act`中记录的所有`Prop`，并将它们各自的`PropState`变量设置为`Act`中指定的目标值。

---

### **5. 未来扩展规划 (V-Next)**

为了管理开发范围，以下高级功能在V1.0中**不作要求**，但系统设计应为其预留扩展空间：

- **5.1 完整的状态快照系统:**
    - 未来，我们可能需要一个更自动化的方式来记录`Prop`的状态，而不仅仅是一个`PropState`整数。例如，自动捕获`Prop`的位置、旋转、材质等。
- **5.2 编辑器内预览功能:**
    - 当完整的状态快照系统实现后，我们希望能有一个“应用预览”按钮，让策划在编辑器中就能即时看到一个`Act`上演时的场景样貌。
- **5.3 动态**`Prop`**增删:**
    - 未来，我们希望一个`Act`不仅能定义现有`Prop`的状态，还能定义在激活时**动态生成**一批新的`Prop`，并在停用时将其销毁。

---

### **6. 核心规则**

- **6.1 边界与归属:** 每个`Stage`拥有明确的物理或逻辑边界。原则上，`Stage`的边界不应重叠，一个`Prop`在同一时间只能被一个`Stage`管理。
- **6.2 存档与持久化:** 系统必须能够将`Stage`的当前状态（如激活的`Act`列表、内部关键变量）写入游戏存档，并在加载时正确恢复。
- **6.3 跨区域通信:** `Stage`之间的交互必须通过一个全局的事件系统来进行，以保持各`Stage`的独立性。
- **6.4 调试:** 系统必须提供运行时的调试工具，让开发者能清晰地看到当前`Stage`的状态、激活的`Act`以及`Prop`的状态来源。

---

### **7. 验收标准**

当以下所有场景都能被流畅地执行时，我们认为该系统的V1.0达到了交付标准：

1. **场景一：核心工作流验证**
    1. 程序员提供一个`AProp`基类，其中包含一个`int32 PropState`变量。
    2. 策划可以创建一个继承自`AProp`的蓝图`BP_Door`。
    3. 策划可以将`BP_Door`的实例注册为一个`Stage`的`Prop`。
    4. 策划可以创建两个`Act`：“Act_Normal”和“Act_Locked”。在`Act_Locked`中，策划为`BP_Door`的`PropState`手动指定值为`1`。
    5. 在`BP_Door`的蓝图中，策划可以编写逻辑：“如果`PropState`的值变为`1`，则播放上锁声效并禁用交互”。
    6. 在游戏中，当`Stage`的逻辑激活`Act_Locked`时，门的行为符合蓝图设计。
2. **场景二：并行开发**
    1. 策划A可以修改“森林`Stage`”的“Act_Raining”；同时策划B可以修改邻近“山谷`Stage`”的“Act_Snowing”，两人提交工作时不产生版本冲突。
3. **场景三：动态加载验证**
    1. “Act_Raining”关联的Data Layer中包含一个下雨特效。在游戏中，只有当“Act_Raining”被激活时，通过调试工具才能确认该资源被加载到了内存中。